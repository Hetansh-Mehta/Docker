# Docker and Kubernetes: The Complete Guide
## Building a Multi-Container Application

## Table of Contents:
1. [Application Overview](#ApplicationOverview)
2. [Dockerizing the React App](#DockerizingReactApp)
3. [Building the Docker-compose File](#DockerComposeFileReactApp)

## Application Overview <a name="ApplicationOverview"></a>

- The application is basically a fibonacci calculator at a particular index which uses multi-container deployment.
- Note, the below architecture is a bit complicated on purpose to explore the multi-container deployment.
- This is what the end application would look like:
![Fibonacci Application Image](./Images/fibonacciAppImage8.png)
- The backend architecture of the application is going to look like the below image. Note, this is just the development architecture, production will be different:
![Development Backend Image](./Images/devBackEndImage8.png)
- When the user boots up their browser, they are first going to visit an nginx web server which is essentially going to do some routing.
- The Nginx server is going to decide if the incoming request wants to access the frontend (React Server) or access APIs to fetch data (Express Server).
- Postgres database will be used for storing the values already seen by the user and Redis server will be used to cache the calculated values (temporary values).
- To sum up, when a user clicks on the submit button, the react app is going to make a request to the express server to write the value to the redis and postgres servers.

## Dockerizing the React App <a name="DockerizingReactApp"></a>

- We create **development** Docker files for each one of the below:
    - React App
    - Express Server
    - Worker
- By having 3 separate dev Docker files, we avoid having to rebuild an image when there is a small change in one of the server. Also by using docker-compose, docker files become organized.
- For each of the above server, we will the same pattern of writing the docker file as below:
![Docker File Format Image](./Images/dockerFileFormatImage8.png)
- The Dockefiles look like below:
```
# Dockefile for React app
FROM node:alpine
WORKDIR '/app'
COPY ./package.json ./
RUN npm install
COPY . .
CMD ["npm","run", "start"]

# Dockerfile for Express Server and Worker
FROM node:alpine
WORKDIR '/app'
COPY ./package.json ./
RUN npm install
COPY . .
CMD ["npm", "run", "dev"]
```
## Building the Docker-compose File <a name="DockerComposeFileReactApp"></a>
- The docker-compose looks like:
- We use **context** to specify the directory where the image **Dockerfile.dev** is present.
- We then specified volumes in a way that puts a hold on node_modules so that it does not override or change it. We then put a reference to the server directory to automatically reflect new changes.
- **ENVIRONMENT VARIABLES WITH DOCKER:**
    - To pass in environment variables to a server, we specify them in a separate section in docker-compose file.
    - Different syntax for specifying environment variables:
    ![Docker File Format Image](./Images/envVariablesSyntaxImage8.png)
        - `variableName=value` sets the variable in a container when a container is run.
        - `variableName` sets the variable by getting the value from the local machine on which the container is running.
    - The default redis port is **6379** and the default password for postgres is **postgres_password** and port is **5432** from docker-hub docs.
    
