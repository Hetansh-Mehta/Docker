# Docker and Kubernetes: The Complete Guide
## Creating a Production-Grade Workflow

## Table of Contents:
1. [Development Workflow](#DevelopmentWorkflow)
2. [Flow Specifics](#FlowSpecifics)
3. [Docker Volumes](#DockerVolumes)

## Development Workflow <a name="DevelopmentWorkflow"></a>

- Development workflow is essentially divided into 3 parts **development**, **testing** and **deployment**.
- Building a software involves the above 3 processes which are then looped back to **development** creating a repeating cycle. This is because not every software built once is perfect.
- Instead we deploy an app, do some additional development and redeploy the app.
![Development Workflow Image](./Images/devWorkflowImage6.png)


## Flow Specifics <a name="FlowSpecifics"></a>

- Essentially, the way we setup the development workflow on github is using a CI/CD platform e.g. TravisCI or CircleCI.
- An example of how a flow could be setup:
    - **Development**
        - Create a repository on github and branch off to work on a feature.
        - Make changes and push them to the child repository.
        - Once the feature is completed, create a pull request to merge the feature with the master branch.
    - **Testing**
        - After the pull request is approved, the code is pushed to TravisCI to run automated tests. The changes get merged only if all the tests pass.
    - **Deployment**
        - After the feature branch is merged to master, the code is pushed to TravisCI and the tests are run again.
        - Once the tests pass, the code is deployed to AWS Elastic Beanstalk.
- Docker is a tool that will make execution of some of these tasks easier.
- We can make 2 seperate docker files for development and production.
- The development docker file is named **Dockerfile.dev** and the production file is the standard **Dockerfile**.
- To run docker build on a custom filename, we use the command: `docker build -f <filename> .` -f specifies the filename, e.g. `docker build -f Dockerfile.dev .`
- Generally when a react frontend is dockeried and a container is created, the node_modules is created inside the container and so make sure to not have node_modules outside the container which will just be duplicate.

## Docker Volumes <a name="DockerVolumes"></a>

- When we run a container and want to edit the source code, we would have to rebuild the image and run a new container to reflect the new changes, to avoid this and get parallel changes, we use Docker Volumes.
- When the **COPY** command copies the source code, it takes a snapshot of the current code into the docker container and this is static that does not reflect new changes.
- Instead, with docker volumes we essentially set a placeholder in the docker container. This placeholder is like a reference point(similar to reference pointers in C or an element of a list - mutable).
![Docker Reference  Image](./Images/dockerReferenceImage6.png)

- The command to setup a docker volume is little complex:
`docker run -p 3000:3000 -v /app/node_modules -v $(pwd):/app <image_id>`
    - `-v $(pwd):/app` essentially maps the pwd to the /app folder running inside the container.
    - `-v /app/node_modules` puts a bookmark on the node_modules folder.
