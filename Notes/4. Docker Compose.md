# Table of Contents
- [Table of Contents](#table-of-contents)
- [1. Docker Compose](#1-docker-compose)

# 1. Docker Compose
Docker Compose is a combination of command line tool and a configuration file. It is a tool for defining and running multi-container Docker applications.

Our containers will often require other containers such as SQL or a key value. With Compose, we use a YAML file to configure the application's services. Then, with a single command, we create and start all the services from the configuration.

Using Compose is basically a three-step process:
1. Define the app's environment with a `Dockerfile` so it can be reproduced anywhere.
2. Define the services that make up the app in `docker-compose.yml` so they can be run together in an isolated environment. This file specifies the containers, the networks, volumes/data mounts, images and other configuration that is required to set up the application.
3. Run `docker-compose up` and Compose starts and runs the entire app.

`docker-compose.yml` file [template](./Dockerfile-Samples/compose-sample-1/template.yml):
```yml
version: '3.1'  # If no version is specified then v1 is assumed. Recommend v2 minimum

services:  # Containers. Same as docker run

  servicename: # A friendly name. this is also DNS name inside network (similar to --name flag in docker run)
    image: # Optional if you use build:
    command: # Optional, replace the default CMD specified by the image
    environment: # Optional, same as -e in docker run
    volumes: # Optional, same as -v in docker run
  
  servicename2:

volumes: # Optional, same as docker volume create

networks: # Optional, same as docker network create
```

Example:
```yaml
version: "3.9"

services:

    redis:
        image: redis:alpine
        ports:
            - "6379"
        networks:
            - frontend
        deploy:
            replicas: 2
            update_config:
                parallelism: 2
                delay: 10s
            restart_policy:
                condition: on-failure
    
    db:
        image: postgres:9.4
        volumes:
            - db-data:/var/lib/postgresql/data
        networks:
            - backend
        deploy:
            placement:
                max_replicas_per_node: 1
                constraints:
                    - "node.role=manager"

networks:
    frontend:
    backend:

volumes:
    db-data:
```

Referring back to bind mounts, we had started a container using the following command:
```commandline
$ cd ./Dockerfile-Samples/bindmount-sample-1

$ docker container run -p 80:4000
-v $(pwd):/site
bretfisher/jekyll-serve
```

We can achieve the same result using the following [`docker-compose.yml` file](./Dockerfile-Samples/compose-sample-1/docker-compose.yml):
```yaml
version: 2

services:
    
    jekyll:
        image: bretfisher/jekyll-serve
        ports:
            - '80:4000'
        volumes:
            - .:/site

# Command:
#  docker container run -p 80:4000 -v $(pwd):/site bretfisher/jekyll-serve
```

Some more examples of docker-compose.yml:
- [Example 1](./Dockerfile-Samples/compose-sample-1/compose-2.yml): Passes environment variables using a `key:value` format.
- [Example 2](./Dockerfile-Samples/compose-sample-1/compose-3.yml): Passes environment variables using a list `- env_var` format. Also introduces the `depends_on` parameter to define relationship between the services.


