# Table of Contents
- [Table of Contents](#table-of-contents)
- [1. Persistent Data: Problem and Solution](#1-persistent-data-problem-and-solution)
  - [1.1. Syntax : `-v` or `--mount` flag](#11-syntax---v-or---mount-flag)
- [2. Data Volumes](#2-data-volumes)
  - [2.1. Create and Manage Volumes](#21-create-and-manage-volumes)
  - [2.2. Start a container with a volume](#22-start-a-container-with-a-volume)
- [3. Bind Mounts](#3-bind-mounts)
  - [3.1. Differences between `-v` and `--mount` behavior](#31-differences-between--v-and---mount-behavior)
  - [3.2. Start a container with a bind mount](#32-start-a-container-with-a-bind-mount)
  - [3.3. Bind Mount Example](#33-bind-mount-example)
- [4. Assignment: Database Upgrades (Named Volumes)](#4-assignment-database-upgrades-named-volumes)
- [5. Assignment: Static Site Generator (Bind Mounts)](#5-assignment-static-site-generator-bind-mounts)


# 1. Persistent Data: Problem and Solution

We've only been worrying about what's needed to run a container, not the unique data that might be created once a container is running.

*   Containers are meant to be **immutable** and **ephemeral**. <br>
    The idea here is that we can always throw away a container and create a new one from an image. 
*   This is the idea of **immutable infrastructure** - we don't change
    things once they're running. If a config change needs to happen, or maybe the container version upgrade needs to happen, then we *redeploy a whole new container*. This gives us huge benefits in reliability and consistency, and making changes reproducible.

But what about the data our application produces - the databases, or a key-value stores, or anything that the app spits out into a file?

*   Ideally, the containers shouldn't contain our unique data mixed in with the
    application binaries. This is known as **separation of concerns**.

Docker gives us features to update our application by recreating a new container, and ideally, our unique data is still where it needs to be and was preserved for us while our container was recycled. <br>

This problem of unique data is known as **persistent data**.

Docker provides two solutions:
1.  Data Volumes <br>
    Docker volumes are a configuration option for a container that creates a special location outside of that container's union file system to store unique data. This preserves it across container removals and allows us to attach it to whatever container we want. The container just sees it like a local file path.
2.  Bind Mounts <br>
    Bind mounts are simply us sharing or mounting a *host* directory, or file, into a container. This too looks just like a local file path/directory path to the container. It won't actually know that it's coming from the host.

## 1.1. Syntax : `-v` or `--mount` flag

Originally, the `-v` or `--volume` flag was used for standalone containers and the `--mount` flag was used for swarm services. However, starting with Docker 17.06, you can also use `--mount` with standalone containers.

`--mount` flag is more explicit and verbose. The biggest difference is that the `-v` syntax combines all the options together in one field, while the `--mount` syntax separates them. 

*   `-v` or `--volume`: Consists of three fields, separated by colon characters
    (`:`). The fields must be in the correct order, and the meaning of each field is not immediately obvious.
    *   In the case of named volumes, the first field is the name of the volume,
        and is unique on a given host machine. For anonymous volumes, the first field is omitted.
    *   The second field is the path where the file or directory are mounted in
        the container.
    *   The third field is optional, and is a comma-separated list of options,
        such as `ro`.
    *   Example: <br>
        ```commandline
        docker run -d \
        --name <CONTAINER-NAME> \
        -v <VOLUME-NAME:<CONTAINER-PATH> \
        <IMAGE>
        ```

*   `--mount`: Consists of multiple key-value pairs, separated by commas and each
    consisting of a `<key>=<value>` tuple. The order of the keys is not significant, and the value of the flag is easier to understand.
    *   The `type` of the mount, which can be `bind`, `volume`, or `tmpfs`.
    *   The `source` of the mount. For named volumes, this is the name of the
        volume. For anonymous volumes, this field is omitted. May be specified as `source` or `src`.
    *   The `destination` takes as its value the path where the file or the
        directory is mounted in the container. May be specified as `destination`, `dst`, or `target`.
    *   The `readonly` option, if present, causes the bind mount to be mounted into
        the container as read-only.
    *   The `volume-opt` option, which can be specified more than once, takes a
        key-value pair consisting of the option name and its value.
    *   Example: <br>
        ```commandline
        docker run -d \
        --name <CONTAINER-NAME> \
        --mount type=volume,src=<VOLUME-NAME>,dst=<CONTAINER-PATH> \
        <IMAGE>
        ```

# 2. Data Volumes

Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. 

Volumes are often a better choice than persisting data in a container’s writable layer, because a volume does not increase the size of the containers using it, and the volume’s contents exist outside the lifecycle of a given container.

*   When you create a volume, it is stored within a directory on the Docker host.
    When you mount the volume into a container, this directory is what is mounted into the container. 
*   A given volume can be mounted into multiple containers simultaneously. When no
    running container is using a volume, the volume is still available to Docker and is not removed automatically.
*   Volumes may be *named* or *anonymous*. Anonymous volumes are not given an
    explicit name when they are first mounted into a container, so Docker gives them a random name that is guaranteed to be unique within a given Docker host.
*   Volumes also support the use of volume drivers, which allow you to store your
    data on remote hosts or cloud providers

Consider this [MySQL Dockerfile](https://github.com/docker-library/mysql/blob/b0f81a33748561ae4e35a09895b2ad112ff89ba6/8.0/Dockerfile). 
It contains the following command: <br>
```dockerfile
VOLUME /var/lib/mysql
```
*   `/var/lib/mysql` is the default location of the MySQL databases.
*   The image tells Docker that when we start a new container from it, to create a
    new volume location and assign it to the above directory in the container.

## 2.1. Create and Manage Volumes

We can create and manage volumes outside the scope of any container.

*   Create a volume: <br>
    `$docker volume create my-vol`
*   List Volumes: <br>
    ```commandline
    $ docker volume ls 
    local          my-vol
    ```
*   Inspect a volume:
    ```commandline
    $ docker volume inspect my-vol
    [
        {
            "Driver": "local",
            "Labels": {},
            "Mountpoint": "/var/lib/docker/volumes/my-vol/_data",
            "Name": "my-vol",
            "Options": {},
            "Scope": "local"
        }
    ]
    ```
*   Remove a volume:
    `$ docker volume rm my-vol`


## 2.2. Start a container with a volume

If you start a container with a volume that does not yet exist, Docker creates the volume for you.

Let's create a MySQL container. The following example mounts the volume
`myvol2` into `/var/lib/mysql/` in the container.
*   Using `--mount` format:
    ```
    docker container run -d \
    --name mysql -e MYSQL_ALLOW_EMPTY_PASSWORD=True \
    --mount type=volume,src=myvol2,dst=/var/lib/mysql  \
    mysql
    ```
    Using `-v` format:
    ```
    docker container run -d \
    --name mysql -e MYSQL_ALLOW_EMPTY_PASSWORD=True \
    -v myvol2:/var/lib/mysql    \
    mysql
    ```

Use `docker container inspect mysql` to verify that the volume was created and
mounter correctly. Look for the `Mounts` section:
*   ```json
    "Mounts": [
        {
            "Type": "volume",
            "Name": "myvol2",
            "Source": "/var/lib/docker/volumes/myvol2/_data",
            "Destination": "/var/lib/mysql",
            "Driver": "local",
            "Mode": "z",
            "RW": true,
            "Propagation": ""
        }
    ],
    ```
    This shows that the mount is a volume, it shows the correct source and destination, and that the mount is read-write.

Use `docker volume inspect myvol2` to get more data for the newly created volume:
*   ```json
    [
        {
            "CreatedAt": "2020-08-28T03:33:33Z",
            "Driver": "local",
            "Labels": null,
            "Mountpoint": "/var/lib/docker/volumes/myvol2/_data",
            "Name": "myvol2",
            "Options": null,
            "Scope": "local"
        }
    ]
    ```

If the volume name is not specified, docker creates a unique volume name for you.

Even when we stop and remove the container, the volume still remains on the
host. Volume removal is a separate step. <br>     
`docker volume rm myvol2`


# 3. Bind Mounts

*   When we use a bind mount, a file or directory on the host machine is mounted
    into a container. The file or directory is referenced by its full path on the host machine. 
*   The file or directory does not need to exist on the Docker host already. It is
    created on demand if it does not yet exist. 
*   Bind mounts are very performant, but they rely on the host machine’s
    filesystem having a specific directory structure available. 
*   **Bind mounts allow access to sensitive files**. One side effect of using bind
    mounts, for better or for worse, is that you can change the host filesystem via processes running in a container, including creating, modifying, or deleting important system files or directories. This is a powerful ability which can have security implications, including impacting non-Docker processes on the host system.

## 3.1. Differences between `-v` and `--mount` behavior

Because the `-v` and `--volume` flags have been a part of Docker for a long time, their behavior cannot be changed. This means that there is one behavior that is different between -v and --mount.

If you use `-v` or `--volume` to bind-mount a file or directory that does not yet exist on the Docker host, `-v` creates the endpoint for you. It is always created as a directory.

If you use `--mount` to bind-mount a file or directory that does not yet exist on the Docker host, Docker does not automatically create it for you, but generates an error.

## 3.2. Start a container with a bind mount

Consider a case where you have a directory `source` and that when you build the source code, the artifacts are saved into another directory, `source/target/`. You want the artifacts to be available to the container at `/app/`, and you want the container to get access to a new build each time you build the source on your development host.

Use the following command to bind-mount the `target/` directory into your container at `/app/`. Run the command from within the source directory. 

The `$(pwd)` sub-command expands to the current working directory on Linux or macOS hosts.
*   Using `--mount` format:
    ```commandline
    $ docker run -d \
    -it \
    --name devtest \
    --mount type=bind,src="$(pwd)/target",dst=/app \
    nginx
    ```
    Using `-v` format:
    ```commandline
    $ docker run -d \
    -it \
    --name devtest \
    -v "$(pwd)"/target:/app \
    nginx
    ```

Use `docker inspect devtest` to verify that the bind mount was created correctly. Look for the `Mounts` section:
*   ```json
    "Mounts": [
        {
            "Type": "bind",
            "Source": "/tmp/source/target",
            "Destination": "/app",
            "Mode": "",
            "RW": true,
            "Propagation": "rprivate"
        }
    ],
    ```
    This shows that the mount is a `bind` mount, it shows the correct source and destination, it shows that the mount is read-write, and that the propagation is set to `rprivate`.

Stop the container:
*   ```commandline
    $ docker container stop devtest

    $ docker container rm devtest
    ```

## 3.3. Bind Mount Example
[This](./Dockerfile-Samples/dockerfile-sample-2/Dockerfile) Dockerfile just specifies a working directory using `WORKDIR` and copies an `index.html` file into that directory. There are no volumes here.

Let's run an `nginx` container with `index.html` by providing a bind mount. 

- We will be mounting the directory containing the dockerfile and index.html into the container.

1. Change the `pwd` to the directory we want to mount:
    ```commandline
    $ cd ./Dockerfile-Samples/docker-file-sample-2/
    ```

2. Start a docker container
   ```commandline
    $ docker run -d                 \
    --name nginx_BM                 \
    -p 80:80                        \
    -v $(pwd):/usr/share/nginx/html \
    nginx 
   ```
   <img src="https://i.imgur.com/1ZseZw6.png" alt="BM Command">

3. Open `localhost` on a web-browser. We can see that it mapped the `index.html` file in the `nginx_BM` container.
   <img src="https://i.imgur.com/LZVHxPo.png" alt="Bind Mount">

4. Let's access the same directory from the container. We can use the `exec -it` command to open a `bash` terminal inside the newly created container.
   ```commandline
    $ docker container exec -it nginx_BM bash

    [root@123dummy456] cd usr/share/nginx/html
   ```
   <img src="https://i.imgur.com/W1PTbw2.png" alt="BM Exec -it">

    We can now access the directory and store/manipulate data on it.

    1. As an example, let's create a text file on the container and write some dummy text in it.
        ```commandline
        [root@123dummy456] echo "This is a test file" > testfile.txt
        [root@123dummy456]
        [root@123dummy456] ls
        ``` 
        <img src="https://i.imgur.com/cQsSGDx.png" alt="BM test file on container">
    
    2. Let's move back to the host machine now and reopen the same directory (`./Dockerfile-Samples/dockerfile-sample2`) and open the newly created `testfile.txt` that was created on the container.
        ```commandline
        $ cd ./Dockerfile-Samples/dockerfile-sample2
        $
        $ cat testfile.txt
        ```
        <img src = "https://i.imgur.com/IbQ7lnJ.png" alt="BM Test file on host">

5. If we delete the files on the container, they would be deleted from the host as well.


# 4. Assignment: Database Upgrades (Named Volumes)
- Imagine a situation that we are running `postgres:9.6.1` and we encounter a situation where we're needed to update tha patch version because of a security issue. 
- We need to replace the container with a new version, but what do we do with the database ? 

<img src="https://i.imgur.com/ohS3K5M.png" alt="Assignment - Named Volumes">

[This](https://hub.docker.com/layers/postgres/library/postgres/9.6.1/images/sha256-4023a747a01a29f94939c41fc5c2441837d9ebc05030c2681dc47853d73978c5?context=explore) link corresponds to version `9.6.1.`. 

- As we can see, on layer 19, the `VOLUME` command is given with path `/var/lib/postgresql/data`

1. Create a `psql` container using the following command:
    ```commandline
    $ docker container run -d            \
    --name psql                          \
    -v psql_vol:/var/lib/postgresql/data \
    postgres:9.6.1
    ```
    <img src="https://i.imgur.com/sEScaJz.png" alt="psql">

2. Follow the container logs:
    ```commandline
    $ docker container logs -f psql
    ```
    <img src="https://i.imgur.com/MXhBQ6X.png" alt="psql logs">

3. Stop the container using `docker container stop psql` and create a new container using `postgres:9.6.2` version to fix the security bug.
   ```commandline
    $ docker container run -d               \
    --name psql_2                           \
    -v psql_vol:/var/lib/postgresql/data    \
    postgres:9.6.2
   ```
    <img src="https://i.imgur.com/maYkmKI.png" alt="psql_2">

4. Check the volumes using `docker volume ls`. There must be only 1 volume as we've used `psql_vol` for both the containers.
   <img src="https://i.imgur.com/jtcnTCK.png" alt="docker volume ls">


5. Check the container logs. They must be the same. The database system is ready to accept connections and has been successfully updated.
   ```commandline
   $ docker container logs -f psql_2
   ```
   <img src="https://i.imgur.com/azu3J8v.png" alt="psql_2 logs">


# 5. Assignment: Static Site Generator (Bind Mounts)
Idea: Taking host data stored on the host computer, mounting that into a container, then changing it on the host and watching it be reflected inside the container.

Click [here](https://jekyllrb.com) to find out more about Jekyll.

<img src="https://i.imgur.com/njsf1BD.png" alt="Assignment - Bind Mounts">

1. Start container using the following command:
   ```commandline
    $ cd ./Dockerfile-Samples/bindmount-sample-1

    $ docker container run -p 80:4000
    -v $(pwd):/site
    bretfisher/jekyll-serve
    ```
    <img src="https://i.imgur.com/5tpcYSz.png" alt="Jekyll Container">

2. Run `localhost` on a web-browser. The default website has one post.
    <img src="https://i.imgur.com/fp7kgup.png" alt="localhost">

3. Go over to the code editor and open [this](./Dockerfile-Samples/bindmount-sample-1/_posts/2017-03-05-welcome-to-jekyll.markdown) file. Change the title.

4. When the change is made, the logs will immediately reflect it. 
    <img src="https://i.imgur.com/i7XUe7q.png" alt="logs">

5. Refresh your web browser and the changes are reflected immediately.
    <img src="https://i.imgur.com/LQbYaKr.png" alt="hello docker">

The container sees the file changes on the host and updates it code. 