# Container Lifetime & Persistent Data

# Table of Contents
1.  [Persistent Data: Problem and Solution](#PersistentData)
    1. [Syntax : `-v` or `--mount` flag](#Syntax)
2. [Data Volumes](#DataVolumes)
    1. [Create and Manage Volumes](#CreateManageVolumes)
    2. [Start a container with a volume](#ContainerVolumes)
3. [Bind Mounts](#BindMounts)
    1. [Differences between `-v` and `--mount` behavior](#DiffBehavior)
    2. [Start a container with a bind mount](#ContainerBindMount)


## 1. Persistent Data: Problem and Solution <a name="PersistentData"></a>>

We've only been worrying about what's needed to run a container, not the unique data that might be created once a container is running.

*   Containers are meant to be **immutable** and **ephemeral**. <br>
    The idea here is that we can always throw away a container and create a new one from an image. 
*   This is the idea of **immutable infrastructure** - we don't change things
    once they're running. If a config change needs to happen, or maybe the container version upgrade needs to happen, then we *redeploy a whole new container*. This gives us huge benefits in reliability and consistency, and making changes reproducible.

But what about the data our application produces - the databases, or a key-value stores, or anything that the app spits out into a file?

*   Ideally, the containers shouldn't contain our unique data mixed in with the
    application binaries. This is known as **spearation of concerns**.

Docker gives us features to update our application by recreating a new container, and ideally, our unique data is still where it needs to be and was preserved for us while our container was recycled. <br>

This problem of unique data is known as **persistent data**.

Docker provides two solutions:
1.  Data Volumes <br>
    Docker volumes are a configuration option for a container that creates a special location outside of that container's union file system to store unique data. This preserves it across container removals and allows us to attach it to whatever container we want. The container just sees it like a local file path.
2.  Bind Mounts <br>
    Bind mounts are simply us sharing or mounting a *host* directory, or file, into a container. This too looks just like a local file path/directory path to the container. It won't actually know that it's coming from the host.

### 1.1. Syntax : `-v` or `--mount` flag <a name="Syntax"></a>

Originally, the `-v` or `--volume` flag was used for standalone containers and the `--mount` flag was used for swarm services. However, starting with Docker 17.06, you can also use `--mount` with standalone containers.

`--mount` flag is more explicit and verbose. The biggest difference is that the `-v` syntax combines all the options together in one field, while the `--mount` syntax separates them. 

*   `-v` or `--volume`: Consists of three fields, separated by colon characters
    (`:`). The fields must be in the correct order, and the meaning of each field is not immediately obvious.
    *   In the case of named volumes, the first field is the name of the volume,
        and is unique on a given host machine. For anonymous volumes, the first field is omitted.
    *   The second field is the path where the file or directory are mounted in
        the container.
    *   The third field is optional, and is a comma-separated list of options,
        such as `ro`.
    *   Example: <br>
        ```commandline
        docker run -d \
        --name <CONTAINER-NAME> \
        -v <VOLUME-NAME:<CONTAINER-PATH> \
        <IMAGE>
        ```

*   `--mount`: Consists of multiple key-value pairs, separated by commas and each
    consisting of a `<key>=<value>` tuple. The order of the keys is not significant, and the value of the flag is easier to understand.
    *   The `type` of the mount, which can be `bind`, `volume`, or `tmpfs`.
    *   The `source` of the mount. For named volumes, this is the name of the
        volume. For anonymous volumes, this field is omitted. May be specified as `source` or `src`.
    *   The `destination` takes as its value the path where the file or the
        directory is mounted in the container. May be specified as `destination`, `dst`, or `target`.
    *   The `readonly` option, if present, causes the bind mount to be mounted into
        the container as read-only.
    *   The `volume-opt` option, which can be specified more than once, takes a
        key-value pair consisting of the option name and its value.
    *   Example: <br>
        ```commandline
        docker run -d \
        --name <CONTAINER-NAME> \
        --mount type=volume,src=<VOLUME-NAME>,dst=<CONTAINER-PATH> \
        <IMAGE>
        ```

## 2. Data Volumes <a name="DataVolumes"></a>

Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. 

Volumes are often a better choice than persisting data in a container’s writable layer, because a volume does not increase the size of the containers using it, and the volume’s contents exist outside the lifecycle of a given container.

*   When you create a volume, it is stored within a directory on the Docker host.
    When you mount the volume into a container, this directory is what is mounted into the container. 
*   A given volume can be mounted into multiple containers simultaneously. When no
    running container is using a volume, the volume is still available to Docker and is not removed automatically.
*   Volumes may be *named* or *anonymous*. Anonymous volumes are not given an
    explicit name when they are first mounted into a container, so Docker gives them a random name that is guaranteed to be unique within a given Docker host.
*   Volumes also support the use of volume drivers, which allow you to store your
    data on remote hosts or cloud providers

Consider this [MySQL Dockerfile](https://github.com/docker-library/mysql/blob/b0f81a33748561ae4e35a09895b2ad112ff89ba6/8.0/Dockerfile). 
It contains the following command: <br>
```dockerfile
VOLUME /var/lib/mysql
```
*   `/var/lib/mysql` is the default location of the MySQL databases.
*   The image tells Docker that when we start a new container from it, to create a
    new volume location and assign it to the above directory in the container.

### 2.1. Create and Manage Volumes <a name="CreateManageVolumes"></a>

We can create and manage volumes outside the scope of any container.

*   Create a volume: <br>
    `$docker volume create my-vol`
*   List Volumes: <br>
    ```commandline
    $ docker volume ls 
    lcoal          my-vol
    ```
*   Inspect a volume:
    ```commandline
    $ docker volume inspect my-vol
    [
        {
            "Driver": "local",
            "Labels": {},
            "Mountpoint": "/var/lib/docker/volumes/my-vol/_data",
            "Name": "my-vol",
            "Options": {},
            "Scope": "local"
        }
    ]
    ```
*   Remove a volume:
    `$ docker volume rm my-vol`


### 2.2. Start a container with a volume <a name="ContainerVolumes"></a>

If you start a container with a volume that does not yet exist, Docker creates the volume for you.

Let's create a MySQL container. The following example mounts the volume
`myvol2` into `/var/lib/mysql/` in the container.
*   Using `--mount` format:
    ```
    docker container run -d \
    --name mysql -e MYSQL_ALLOW_EMPTY_PASSWORD=True \
    --mount type=volume,src=myvol2,dst=/var/lib/mysql  \
    mysql
    ```
    Using `-v` format:
    ```
    docker container run -d \
    --name mysql -e MYSQL_ALLOW_EMPTY_PASSWORD=True \
    -v myvol2:/var/lib/mysql    \
    mysql
    ```

Use `docker container inspect mysql` to verify that the volume was created and
mounter correctly. Look for the `Mounts` section:
*   ```json
    "Mounts": [
        {
            "Type": "volume",
            "Name": "myvol2",
            "Source": "/var/lib/docker/volumes/myvol2/_data",
            "Destination": "/var/lib/mysql",
            "Driver": "local",
            "Mode": "z",
            "RW": true,
            "Propagation": ""
        }
    ],
    ```
    This shows that the mount is a volume, it shows the correct source and destination, and that the mount is read-write.

Use `docker volume inspect myvol2` to get more data for the newly created volume:
*   ```json
    [
        {
            "CreatedAt": "2020-08-28T03:33:33Z",
            "Driver": "local",
            "Labels": null,
            "Mountpoint": "/var/lib/docker/volumes/myvol2/_data",
            "Name": "myvol2",
            "Options": null,
            "Scope": "local"
        }
    ]
    ```

If the volume name is not specified, docker creates a unique volume name for you.

Even when we stop and remove the container, the volume still remains on the
host. Volume removal is a separate step. <br>     
`docker volume rm myvol2`


## 3. Bind Mounts <a name="BindMounts"></a>>

*   When we use a bind mount, a file or directory on the host machine is mounted
    into a container. The file or directory is referenced by its full path on the host machine. 
*   The file or directory does not need to exist on the Docker host already. It is
    created on demand if it does not yet exist. 
*   Bind mounts are very performant, but they rely on the host machine’s
    filesystem having a specific directory structure available. 
*   **Bind mounts allow access to sensitive files**. One side effect of using bind
    mounts, for better or for worse, is that you can change the host filesystem via processes running in a container, including creating, modifying, or deleting important system files or directories. This is a powerful ability which can have security implications, including impacting non-Docker processes on the host system.

### 3.1. Differences between `-v` and `--mount` behavior <a name="DiffBehavior"></a>

Because the `-v` and `--volume` flags have been a part of Docker for a long time, their behavior cannot be changed. This means that there is one behavior that is different between -v and --mount.

If you use `-v` or `--volume` to bind-mount a file or directory that does not yet exist on the Docker host, `-v` creates the endpoint for you. It is always created as a directory.

If you use `--mount` to bind-mount a file or directory that does not yet exist on the Docker host, Docker does not automatically create it for you, but generates an error.

### 3.2. Start a container with a bind mount <a name="ContainerBindMount"></a>

Consider a case where you have a directory `source` and that when you build the source code, the artifacts are saved into another directory, `source/target/`. You want the artifacts to be available to the container at `/app/`, and you want the container to get access to a new build each time you build the source on your development host.

Use the following command to bind-mount the `target/` directory into your container at `/app/`. Run the command from within the source directory. 

The `$(pwd)` sub-command expands to the current working directory on Linux or macOS hosts.
*   Using `--mount` format:
    ```commandline
    $ docker run -d \
    -it \
    --name devtest \
    --mount type=bind,src="$(pwd)/target",dst=/app \
    nginx
    ```
    Using `-v` format:
    ```commandline
    $ docker run -d \
    -it \
    --name devtest \
    -v "$(pwd)"/target:/app \
    nginx
    ```

Use `docker inspect devtest` to verify that the bind mount was created correctly. Look for the `Mounts` section:
*   ```json
    "Mounts": [
        {
            "Type": "bind",
            "Source": "/tmp/source/target",
            "Destination": "/app",
            "Mode": "",
            "RW": true,
            "Propagation": "rprivate"
        }
    ],
    ```
    This shows that the mount is a `bind` mount, it shows the correct source and destination, it shows that the mount is read-write, and that the propagation is set to rprivate.

Stop the container:
*   ```commandline
    $ docker container stop devtest

    $ docker container rm devtest
    ```
